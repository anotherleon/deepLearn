<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>TEST</title>
    <style>
        body {
            padding: 16px 32px;
        }

        pre {
            padding: 16px;
            line-height: 1.5;
            background-color: #f5f5f5;
        }
    </style>
</head>

<body>
    <H3></H3>
    <pre>

    </pre>

    <script>

        const PENDING = "pending";
        const FULFILLED = "fulfilled";
        const REJECTED = "rejected";

        function Promise(excutor) {
            let that = this; // 缓存当前promise实例对象
            that.status = PENDING; // 初始状态
            that.value = undefined; // fulfilled状态时 返回的信息
            that.reason = undefined; // rejected状态时 拒绝的原因
            that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数
            that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数

            function resolve(value) { // value成功态时接收的终值
                if (value instanceof Promise) {
                    return value.then(resolve, reject);
                }
                // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。
                setTimeout(() => {
                    // 调用resolve 回调对应onFulfilled函数
                    if (that.status === PENDING) {
                        // 只能由pending状态 => fulfilled状态 (避免调用多次resolve reject)
                        that.status = FULFILLED;
                        that.value = value;
                        that.onFulfilledCallbacks.forEach(cb => cb(that.value));
                    }
                });
            }
            function reject(reason) { // reason失败态时接收的拒因
                setTimeout(() => {
                    // 调用reject 回调对应onRejected函数
                    if (that.status === PENDING) {
                        // 只能由pending状态 => rejected状态 (避免调用多次resolve reject)
                        that.status = REJECTED;
                        that.reason = reason;
                        that.onRejectedCallbacks.forEach(cb => cb(that.reason));
                    }
                });
            }

            // 捕获在excutor执行器中抛出的异常
            // new Promise((resolve, reject) => {
            //     throw new Error('error in excutor')
            // })
            try {
                excutor(resolve, reject);
            } catch (e) {
                reject(e);
            }
        }

        Promise.prototype.then = function (onFulfilled, onRejected) {
            const that = this;
            let newPromise;
            // 处理参数默认值 保证参数后续能够继续执行
            onFulfilled =
                typeof onFulfilled === "function" ? onFulfilled : value => value;
            onRejected =
                typeof onRejected === "function" ? onRejected : reason => {
                    throw reason;
                };
            if (that.status === FULFILLED) { // 成功态
                return newPromise = new Promise((resolve, reject) => {
                    setTimeout(() => {
                        try {
                            let x = onFulfilled(that.value);
                            resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值
                        } catch (e) {
                            reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);
                        }
                    });
                })
            }

            if (that.status === REJECTED) { // 失败态
                return newPromise = new Promise((resolve, reject) => {
                    setTimeout(() => {
                        try {
                            let x = onRejected(that.reason);
                            resolvePromise(newPromise, x, resolve, reject);
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
            }

            if (that.status === PENDING) { // 等待态
                // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中
                return newPromise = new Promise((resolve, reject) => {
                    that.onFulfilledCallbacks.push((value) => {
                        try {
                            let x = onFulfilled(value);
                            resolvePromise(newPromise, x, resolve, reject);
                        } catch (e) {
                            reject(e);
                        }
                    });
                    that.onRejectedCallbacks.push((reason) => {
                        try {
                            let x = onRejected(reason);
                            resolvePromise(newPromise, x, resolve, reject);
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
            }
        };


        ; (function () {
            /**
            * 1. new Promise时，需要传递一个 executor 执行器，执行器立刻执行
            * 2. executor 接受两个参数，分别是 resolve 和 reject
            * 3. promise 只能从 pending 到 rejected, 或者从 pending 到 fulfilled
            * 4. promise 的状态一旦确认，就不会再改变
            * 5. promise 都有 then 方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 
            *      和 promise 失败的回调 onRejected
            * 6. 如果调用 then 时，promise已经成功，则执行 onFulfilled，并将promise的值作为参数传递进去。
            *      如果promise已经失败，那么执行 onRejected, 并将 promise 失败的原因作为参数传递进去。
            *      如果promise的状态是pending，需要将onFulfilled和onRejected函数存放起来，等待状态确定后，再依次将对应的函数执行(发布订阅)
            * 7. then 的参数 onFulfilled 和 onRejected 可以缺省
            * 8. promise 可以then多次，promise 的then 方法返回一个 promise
            * 9. 如果 then 返回的是一个结果，那么就会把这个结果作为参数，传递给下一个then的成功的回调(onFulfilled)
            * 10. 如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个then的失败的回调(onRejected)
            * 11.如果 then 返回的是一个promise,那么需要等这个promise，那么会等这个promise执行完，promise如果成功，
            *   就走下一个then的成功，如果失败，就走下一个then的失败
            */

            const PENDING = 'pending';
            const FULFILLED = 'fulfilled';
            const REJECTED = 'rejected';
            function Promise(executor) {
                let self = this;
                self.status = PENDING;
                self.onFulfilled = [];//成功的回调
                self.onRejected = []; //失败的回调
                //PromiseA+ 2.1
                function resolve(value) {
                    if (self.status === PENDING) {
                        self.status = FULFILLED;
                        self.value = value;
                        self.onFulfilled.forEach(fn => fn());//PromiseA+ 2.2.6.1
                    }
                }

                function reject(reason) {
                    if (self.status === PENDING) {
                        self.status = REJECTED;
                        self.reason = reason;
                        self.onRejected.forEach(fn => fn());//PromiseA+ 2.2.6.2
                    }
                }

                try {
                    executor(resolve, reject);
                } catch (e) {
                    reject(e);
                }
            }

            Promise.prototype.then = function (onFulfilled, onRejected) {
                //PromiseA+ 2.2.1 / PromiseA+ 2.2.5 / PromiseA+ 2.2.7.3 / PromiseA+ 2.2.7.4
                onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
                onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };
                let self = this;
                //PromiseA+ 2.2.7
                let promise2 = new Promise((resolve, reject) => {
                    if (self.status === FULFILLED) {
                        //PromiseA+ 2.2.2
                        //PromiseA+ 2.2.4 --- setTimeout
                        setTimeout(() => {
                            try {
                                //PromiseA+ 2.2.7.1
                                let x = onFulfilled(self.value);
                                resolvePromise(promise2, x, resolve, reject);
                            } catch (e) {
                                //PromiseA+ 2.2.7.2
                                reject(e);
                            }
                        });
                    } else if (self.status === REJECTED) {
                        //PromiseA+ 2.2.3
                        setTimeout(() => {
                            try {
                                let x = onRejected(self.reason);
                                resolvePromise(promise2, x, resolve, reject);
                            } catch (e) {
                                reject(e);
                            }
                        });
                    } else if (self.status === PENDING) {
                        self.onFulfilled.push(() => {
                            setTimeout(() => {
                                try {
                                    let x = onFulfilled(self.value);
                                    resolvePromise(promise2, x, resolve, reject);
                                } catch (e) {
                                    reject(e);
                                }
                            });
                        });
                        self.onRejected.push(() => {
                            setTimeout(() => {
                                try {
                                    let x = onRejected(self.reason);
                                    resolvePromise(promise2, x, resolve, reject);
                                } catch (e) {
                                    reject(e);
                                }
                            });
                        });
                    }
                });
                return promise2;
            }

            function resolvePromise(promise2, x, resolve, reject) {
                let self = this;
                //PromiseA+ 2.3.1
                if (promise2 === x) {
                    reject(new TypeError('Chaining cycle'));
                }
                if (x && typeof x === 'object' || typeof x === 'function') {
                    let used; //PromiseA+2.3.3.3.3 只能调用一次
                    try {
                        let then = x.then;
                        if (typeof then === 'function') {
                            //PromiseA+2.3.3
                            then.call(x, (y) => {
                                //PromiseA+2.3.3.1
                                if (used) return;
                                used = true;
                                resolvePromise(promise2, y, resolve, reject);
                            }, (r) => {
                                //PromiseA+2.3.3.2
                                if (used) return;
                                used = true;
                                reject(r);
                            });

                        } else {
                            //PromiseA+2.3.3.4
                            if (used) return;
                            used = true;
                            resolve(x);
                        }
                    } catch (e) {
                        //PromiseA+ 2.3.3.2
                        if (used) return;
                        used = true;
                        reject(e);
                    }
                } else {
                    //PromiseA+ 2.3.3.4
                    resolve(x);
                }
            }
        })()

        // 定义Promise的三种状态常量
        const PENDING = 'pending'
        const FULFILLED = 'fulfilled'
        const REJECTED = 'rejected'

        class Promise {
            static resolve() { }
            static reject() { }
            static all() { }
            static race() { }
            constructor(executor) {
                this.status = PENDING
                this.value = undefined
                this.reason = undefined
                this.onFulfilledCallbacks = []
                this.onRejectedCallbacks = []
                // const resolve = (value) => {
                //     if (this.status === PENDING) {
                //         this.status = FULFILLED
                //         this.value = value
                //         this.onFulfilledCallbacks.forEach(fn => fn())
                //     }
                // }
                let self = this;
                function resolve(value) {
                    const resolve = (value) => {
                        console.log(value)
                        if (self.status === PENDING) {
                            self.status = FULFILLED
                            self.value = value
                            self.onFulfilledCallbacks.forEach(fn => fn())
                        }
                    }
                    setTimeout(() => { resolve(value) }, 0)
                }
                // const reject = (reason) => {
                //     if (this.status === PENDING) {
                //         this.status = REJECTED
                //         this.reason = reason
                //         this.onRejectedCallbacks.forEach(fn => fn())
                //     }
                // }
                function reject(reason) {
                    const reject = (reason) => {
                        console.log(self)
                        if (self.status === PENDING) {
                            self.status = REJECTED
                            self.reason = reason
                            self.onRejectedCallbacks.forEach(fn => fn())
                        }
                    }
                    setTimeout(reject, 0)
                }

                try {
                    executor(resolve, reject)
                } catch (error) {
                    reject(error)
                }
            }
            then(onFulfilled, onRejected) {
                onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value
                onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }

                const self = this;
                const promiseThen = new Promise((resolve, reject) => {
                    switch (self.status) {
                        case FULFILLED:
                            try {
                                let x = onFulfilled(self.value)
                                resolvePromise(promiseThen, x, resolve, reject);
                            } catch (error) {
                                reject(error)
                            }
                            break;
                        case REJECTED:
                            try {
                                let x = onRejected(self.reason)
                                resolvePromise(promiseThen, x, resolve, reject);
                            } catch (error) {
                                reject(error)
                            }
                            break;
                        case PENDING:
                            this.onFulfilledCallbacks.push(() => {
                                try {
                                    let x = onFulfilled(self.value);
                                    resolvePromise(promiseThen, x, resolve, reject);
                                } catch (error) {

                                }
                            })
                            this.onRejectedCallbacks.push(() => {
                                try {
                                    let x = onRejected(self.reason);
                                    resolvePromise(promiseThen, x, resolve, reject);
                                } catch (error) {
                                    reject(error)
                                }
                            })
                            break;
                    }
                })
                return promiseThen;
            }
            catch() { }
            finally() { }
        }

        function resolvePromise(promise, x, resolve, reject) {
            let self = this;
            if (promise === x) { reject(new TypeError('循环引用')) }
            if (x && typeof x === 'object' || typeof x === 'function') {
                let resolved = false;
                try {
                    let then = x.then;
                    if (typeof then === 'function') {
                        then.call(x, (y) => {
                            if (resolved) return;
                            resolvePromise(promise, y, resolve, reject);
                            resolved = true;
                        }, (err) => {
                            if (resolved) return;
                            reject(err)
                            resolved = true;
                        })
                    } else {
                        if (resolved) return;
                        resolve(x)
                        resolved = true;
                    }

                } catch (error) {
                    if (resolved) return;
                    reject(error)
                    resolved = true;
                }
            } else {
                resolve(x)
            }

        }
        Promise.defer = Promise.deferred = function () {
            let dfd = {};
            dfd.promise = new Promise((resolve, reject) => {
                dfd.resolve = resolve;
                dfd.reject = reject;
            });
            return dfd;
        }

    </script>
</body>

</html>